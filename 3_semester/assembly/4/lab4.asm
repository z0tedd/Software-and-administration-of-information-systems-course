data segment       ; Начало сегмента данных
    fibonacci dw 18 dup(?)      ; Создаем массив из 18 элементов, каждый занимает 2 байта, значения изначально не инициализированы
    min_odd dw 0                ; Переменная для хранения минимального нечетного элемента
    max_even dw 0               ; Переменная для хранения максимального четного элемента
data ends          ; Конец сегмента данных
                                            
code segment       ; Начало сегмента кода
start:
    mov ax, data                ; Загружаем адрес сегмента данных в AX
    mov ds, ax                  ; Устанавливаем сегмент данных DS

    ; Вычисление первых 18 чисел Фибоначчи и их запись в массив
    mov cx, 16                 ; Устанавливаем счетчик на 16 итераций, т.к. первые два числа уже заданы
    
    mov si, 0                  ; Начальный индекс массива fibonacci (указывает на текущий элемент)
    mov di, 0
    mov ax, 0                  ; Первое число Фибоначчи
    mov fibonacci[si], ax   ; Сохраняем первое число в массив
    add si, 2                  ; Переходим к следующему элементу массива (увеличиваем индекс на 2 байта)
    mov ax, 1                  ; Второе число Фибоначчи
    mov fibonacci[si], ax   ; Сохраняем второе число в массив
    add si, 2                  ; Переходим к следующему элементу массива

    ; Генерация оставшихся чисел Фибоначчи
generate_fib:
    mov bx, fibonacci[si - 4] ; Загружаем F(n-2) из массива (смещение на -4 байта)
    add bx, fibonacci[si - 2] ; Добавляем F(n-1) к F(n-2)
    mov fibonacci[si], bx     ; Сохраняем F(n) в массив
    add si, 2                    ; Переходим к следующему элементу массива
    loop generate_fib            ; Повторяем цикл, пока счетчик CX не достигнет нуля

    ; Поиск минимального нечетного элемента во второй строке массива
    mov cx, 6                   ; Количество элементов во второй строке (6 столбцов)
    mov si, 1              ; Начальный индекс второй строки (первый элемент второй строки имеет индекс 6)
    mov di, 0
    mov bx, 0FFFFh              ; Устанавливаем начальное значение минимального элемента как максимально возможное (65535)

find_min_odd:
    mov ax, fibonacci[si][di]    ; Загружаем текущий элемент массива
    test ax, 1                  ; Проверяем, является ли число нечетным (побитовое И с 1)
    jz next_odd                 ; Если четное, пропускаем обработку и переходим к следующему элементу
    cmp ax, bx                  ; Сравниваем текущий элемент с текущим минимальным
    jae next_odd                ; Если больше или равно минимальному, пропускаем обработку
    mov bx, ax                  ; Если меньше, обновляем значение минимального

next_odd:
    add di, 2                   ; Переходим к следующему элементу строки
    loop find_min_odd           ; Повторяем цикл для всех элементов строки
    mov min_odd, bx           ; Сохраняем минимальное нечетное значение в min_odd

    ; Поиск максимального четного элемента в четвертом столбце
    mov cx, 3                   ; Количество строк (всего 3 строки)
    mov di, 2 * 3               ; Начальный индекс четвертого столбца (индекс 3)
    mov si, 0
    mov bx, 0                   ; Устанавливаем начальное значение максимального элемента как минимально возможное (0)

find_max_even:
    mov ax, fibonacci[si][di]    ; Загружаем текущий элемент массива
    test ax, 1                  ; Проверяем, является ли число четным
    jnz next_even               ; Если нечетное, пропускаем обработку и переходим к следующему элементу
    cmp ax, bx                  ; Сравниваем текущий элемент с текущим максимальным
    jbe next_even               ; Если меньше или равно максимальному, пропускаем обработку
    mov bx, ax                  ; Если больше, обновляем значение максимального

next_even:
    ;add si, 2 * 3               ; Переходим к следующей строке в том же столбце
  add si,2
    loop find_max_even          ; Повторяем цикл для всех строк
    mov [max_even], bx          ; Сохраняем максимальное четное значение в max_even

    ; Завершение программы
    mov ax, 4C00h               ; Код завершения программы
    int 21h                     ; Вызов прерывания для завершения программы

code ends                        ; Конец сегмента кода
end start                        ; Конец программы, точка входа — метка start
